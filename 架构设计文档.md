# 安全工具架构设计文档

## 一、架构概述

### 1.1 整体架构风格

本项目采用 **Clean Architecture（清洁架构）** 和 **领域驱动设计（DDD）** 相结合的方式：

```
┌─────────────────────────────────────────┐
│          Presentation Layer             │
│  (API Controllers / React Frontend)     │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│        Application Layer                │
│  (Services / Use Cases / DTOs)          │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│          Domain Layer                   │
│  (Entities / Value Objects / Events)   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│      Infrastructure Layer               │
│  (Repositories / File Storage)          │
└─────────────────────────────────────────┘
```

### 1.2 分层职责

#### Presentation Layer（表现层）
- **职责**：处理HTTP请求/响应，用户界面
- **技术**：.NET Minimal API, React + TypeScript
- **特点**：薄层，仅负责路由和序列化

#### Application Layer（应用层）
- **职责**：业务用例编排，应用服务
- **技术**：C# Services, DTOs
- **特点**：无业务逻辑，仅协调领域对象

#### Domain Layer（领域层）
- **职责**：核心业务逻辑，领域模型
- **技术**：C# Domain Models, Value Objects
- **特点**：独立于基础设施，包含业务规则

#### Infrastructure Layer（基础设施层）
- **职责**：数据持久化，外部服务
- **技术**：File-based Repositories, JSON Storage
- **特点**：可替换实现，依赖倒置

---

## 二、设计模式应用

### 2.1 Repository 模式

**目的**：抽象数据访问，实现持久化无关

**实现位置**：
- `SafeTool.Application/Repositories/IChangeRequestRepository.cs`（接口）
- `SafeTool.Application/Repositories/FileBasedChangeRequestRepository.cs`（实现）

**优势**：
- 业务逻辑与数据存储解耦
- 易于切换存储方式（文件 → 数据库）
- 便于单元测试（可Mock）

**示例**：
```csharp
// 接口定义
public interface IChangeRequestRepository
{
    Task<ChangeRequest?> GetByIdAsync(string id);
    Task<ChangeRequest> CreateAsync(ChangeRequest changeRequest);
    // ...
}

// 服务层使用接口，不依赖具体实现
public class ChangeRequestService
{
    private readonly IChangeRequestRepository _repository;
    // ...
}
```

---

### 2.2 策略模式（Strategy Pattern）

**目的**：封装算法，使其可互换

**应用场景**：

#### 2.2.1 变更影响分析策略
- **接口**：`IChangeImpactAnalyzer`
- **实现**：`ChangeImpactAnalyzer`
- **用途**：不同类型的变更有不同的影响分析逻辑

#### 2.2.2 版本对比策略
- **接口**：`IVersionComparer`
- **实现**：`VersionComparer`
- **用途**：不同资源类型有不同的对比逻辑

#### 2.2.3 CCF评分建议策略
- **服务**：`CcfWizardService.GetRecommendation()`
- **用途**：根据当前评分和可用项，智能推荐措施

**优势**：
- 算法可独立变化
- 易于扩展新的策略
- 符合开闭原则

---

### 2.3 建造者模式（Builder Pattern）

**目的**：分步构建复杂对象

**应用场景**：CCF评分向导

**实现**：
```csharp
public class CcfWizard
{
    private readonly List<CcfWizardStep> _steps = new();
    private int _currentStepIndex = 0;
    
    // 分步构建向导流程
    public CcfWizardStep? GetNextStep() { ... }
    public void SelectItem(string code) { ... }
    public CcfWizardResult GetResult() { ... }
}
```

**优势**：
- 分步引导用户完成复杂流程
- 可控制构建过程
- 支持回退和重做

---

### 2.4 观察者模式（Observer Pattern）

**目的**：实现事件通知机制

**应用场景**：证据到期提醒

**实现**：
```csharp
// 通知服务接口（被观察者）
public interface INotificationService
{
    Task NotifyAsync(Notification notification);
}

// 后台服务（观察者）
public class EvidenceExpiryNotificationService : IHostedService
{
    // 定期检查证据到期情况并发送通知
    private void DoWork(object? state) { ... }
}
```

**优势**：
- 解耦通知发送者和接收者
- 支持多个观察者
- 易于扩展新的通知类型

---

### 2.5 领域事件模式（Domain Events）

**目的**：在领域模型中表达业务事件

**应用场景**：变更请求状态变更

**实现**：
```csharp
public class ChangeRequest
{
    public List<ChangeEvent> Events { get; set; } = new();
    
    public void Approve(string reviewer, string comment, bool isFirstReviewer)
    {
        // 业务逻辑
        Status = ChangeStatus.Approved;
        
        // 记录领域事件
        Events.Add(new ChangeEvent
        {
            Timestamp = DateTime.UtcNow,
            User = reviewer,
            Action = "Approve",
            Description = $"审批变更请求：{comment}"
        });
    }
}
```

**优势**：
- 业务逻辑与事件解耦
- 支持审计追溯
- 可触发后续业务流程

---

### 2.6 服务定位器模式（Service Locator）

**目的**：通过依赖注入获取服务

**应用场景**：所有服务注册

**实现**：
```csharp
// Program.cs 中注册服务
builder.Services.AddSingleton<IChangeRequestRepository, FileBasedChangeRequestRepository>();
builder.Services.AddSingleton<ChangeRequestService>();

// 服务中通过构造函数注入
public class ChangeRequestService
{
    private readonly IChangeRequestRepository _repository;
    
    public ChangeRequestService(IChangeRequestRepository repository)
    {
        _repository = repository;
    }
}
```

**优势**：
- 控制反转（IoC）
- 依赖解耦
- 易于测试和替换

---

## 三、架构原则

### 3.1 依赖倒置原则（DIP）

- **高层模块**（Application Layer）不依赖低层模块（Infrastructure Layer）
- 两者都依赖抽象（Interfaces）
- 示例：`ChangeRequestService` 依赖 `IChangeRequestRepository` 接口，而非具体实现

### 3.2 单一职责原则（SRP）

- 每个类只有一个变化的理由
- 示例：
  - `ChangeRequestService`：仅负责变更请求业务逻辑
  - `EvidenceExpiryNotificationService`：仅负责证据到期检查
  - `CcfWizardService`：仅负责CCF评分向导

### 3.3 开闭原则（OCP）

- 对扩展开放，对修改关闭
- 示例：通过 `IChangeImpactAnalyzer` 接口，可扩展新的影响分析策略，无需修改现有代码

### 3.4 接口隔离原则（ISP）

- 客户端不应依赖它不需要的接口
- 示例：`IChangeRequestRepository` 只包含变更请求相关的操作

### 3.5 里氏替换原则（LSP）

- 子类可以替换父类
- 示例：`FileBasedChangeRequestRepository` 可以替换 `IChangeRequestRepository` 的任何实现

---

## 四、数据流设计

### 4.1 请求处理流程

```
HTTP Request
    ↓
Minimal API Endpoint
    ↓
Application Service (ChangeRequestService)
    ↓
Domain Model (ChangeRequest)
    ↓
Repository (IChangeRequestRepository)
    ↓
File Storage / Database
```

### 4.2 事件驱动流程

```
Domain Event (ChangeRequest.Approve)
    ↓
Application Service (记录事件)
    ↓
Audit Service (记录审计日志)
    ↓
Notification Service (发送通知)
    ↓
Background Service (定期检查)
```

---

## 五、扩展性设计

### 5.1 存储层扩展

当前使用文件存储，未来可扩展为：
- **数据库存储**：实现 `DatabaseChangeRequestRepository : IChangeRequestRepository`
- **云存储**：实现 `CloudChangeRequestRepository : IChangeRequestRepository`
- **混合存储**：根据配置选择存储方式

### 5.2 通知渠道扩展

当前支持内存通知，未来可扩展为：
- **邮件通知**：实现 `EmailNotificationService : INotificationService`
- **短信通知**：实现 `SmsNotificationService : INotificationService`
- **WebSocket推送**：实现 `WebSocketNotificationService : INotificationService`

### 5.3 计算策略扩展

当前支持基础计算，未来可扩展为：
- **高级影响分析**：实现 `AdvancedChangeImpactAnalyzer : IChangeImpactAnalyzer`
- **AI辅助分析**：实现 `AiChangeImpactAnalyzer : IChangeImpactAnalyzer`

---

## 六、性能优化

### 6.1 缓存策略

- **组件库查询**：可引入内存缓存（如 `IMemoryCache`）
- **规则库查询**：可引入缓存减少文件读取

### 6.2 异步处理

- **后台任务**：使用 `IHostedService` 实现定期检查
- **异步操作**：Repository 方法使用 `async/await`

### 6.3 批量操作

- **批量导入**：支持批量创建变更请求
- **批量通知**：支持批量发送通知

---

## 七、测试策略

### 7.1 单元测试

- **领域模型**：测试业务逻辑（如 `ChangeRequest.Approve()`）
- **应用服务**：Mock Repository，测试服务逻辑
- **策略类**：测试不同策略的实现

### 7.2 集成测试

- **Repository测试**：测试数据持久化
- **API测试**：测试端到端流程

### 7.3 测试工具

- **Mock框架**：Moq / NSubstitute
- **测试框架**：xUnit / NUnit
- **集成测试**：TestServer

---

## 八、安全设计

### 8.1 认证与授权

- **JWT认证**：基于Token的无状态认证
- **角色控制**：支持细粒度RBAC（待实现）

### 8.2 数据安全

- **审计日志**：所有关键操作记录审计日志
- **版本控制**：变更请求支持版本对比
- **防篡改**：审计事件签名（待实现）

### 8.3 输入验证

- **参数校验**：API层参数验证
- **业务规则校验**：领域模型内校验

---

## 九、总结

### 9.1 架构优势

1. **可维护性**：清晰的分层和职责划分
2. **可扩展性**：基于接口的设计，易于扩展
3. **可测试性**：依赖注入和接口抽象，便于Mock
4. **可替换性**：基础设施层可替换实现

### 9.2 设计模式总结

| 设计模式 | 应用场景 | 优势 |
|---------|---------|------|
| Repository | 数据访问抽象 | 解耦业务与存储 |
| Strategy | 算法封装 | 易于扩展新策略 |
| Builder | 复杂对象构建 | 分步引导流程 |
| Observer | 事件通知 | 解耦通知机制 |
| Domain Events | 领域事件 | 业务追溯与审计 |

### 9.3 后续优化方向

1. **引入MediatR**：实现CQRS模式，进一步解耦
2. **引入AutoMapper**：简化DTO映射
3. **引入FluentValidation**：统一参数验证
4. **引入Serilog**：结构化日志记录
5. **引入Polly**：实现重试和熔断机制

---

**文档版本**：v1.0  
**最后更新**：2025年1月  
**维护者**：开发团队

